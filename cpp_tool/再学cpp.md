# 2023

### 引用&

- 引用不是变量
- 引用仅仅是变量的别名
- 引用没有自己独立的空间
- 引用要与它所引用的变量共享空间
- 对引用所要作的改变实际上对于它所引用的改变

- 引用的两个作用: 应用作为参数传递, 引用作为返回值
  - c语言中具有两种传参方式: 值传递-形参值的改变不能对实参产生影响，指针传递通过形参的改变使相应的实参改变，但程序容易产生错误且难以阅读
  - c++多了引用作为参数对传参的任何操作都能改变相应的实参的数据，使函数调用显得简单

### name managling 与 extern c

- c++重载中主要是对函数的名字进行了名字改编，c语言是不可以对名字进行名字改编的
- 如果c++中的函数不想改编，就添加extern c就可以

### inline与define

- 内联函数:当程序执行函数调用时，系统要建立栈空间，保护现场，传递参数以及控制程序的转移等等，这些工作需要系统时间和空间的开销, 有些情况下，函数本身功能简单，
代码很短，但使用频率却很高，程序频繁调用该函数所花费的时间却很多，从而使得程序执行效率降低。
- 为了提高效率，一个解决办法就是不使用函数，直接将函数的代码嵌入到程序中，这种方法一是相同代码重复书写，二是程序可读性往往没有使用函数的好。
- 为了协调好效率和可读性之间的矛盾，c++提供了另一种方法，及定义内联函数，方法是再定义函数时用修饰次inline
- 内敛函数与带参数宏定义的区别: 内敛函数调用时，要求参数和形参的类型一致，另外内敛函数会对实参表达式进行求值，然后传递给形参，而宏调用时只用实参简单地替换形参。
- 内联函数是在编译的时候，在编译的地方将代码展开的，而宏则是在预处理进行替换的
- 而C++中建议采用inline函数来替换带参数的宏。

### 类型转换
- const\cast
    - 用来移除对象的常量性(const away the constness)
    - const\_cast一般用于指针或者引用
    - 使用const\_cast去除const限定的目的不是为了修改它的内容
    - 使用const\_cast去除const限定，通常是为了函数能够接受这个实际参数
- static\_cast
    - 编译器隐式执行的任何类型转换都是可以static\_cast完成。
    - 当一个较大的算数类型赋值给较小的类型时，可以用shared\_cast进行强制转换。
    - 可以将void* 指针转换为某一类型的指针
    - 可以将基类指针指向派生类指针
    - 无法将const转化为nonconst;这个只有const\_cast才可以办得到
- reinterpret\_cast
    - reinterpret\_cast通常为操作数的位模式提供较低的重新解释，也就是说将数据以二进制存在形式的重新解释。
- dynamic\_cast基类与派生类向下转化

### c++ 类的特性

- 抽象
- 封装
- 继承
- 多态
- 类的设计需要满足开闭原则，软件中的对象(类,模块,函数)应该对于扩展是开放的，对于类的修改是关闭

### 类的构造和析构
- const成员的初始化只能在构造函数初始化列表中进行
- 引用成员的初始化只能在构造函数初始化列表中进行
- 类成员的初始化顺序与初始化列表无关，而与类的私有变量定义顺序有关
- 对于所有的对象都是常量，需要定义为枚举，而不是const
- 当函数的形参是类的对象，调用函数时，进行形参与实参的结合使用，这时要在内存中新建立一个局部对象，并把实参拷贝到新的对象中，理所当然也在调用拷贝构造。
- 当函数的返回值是类的对象，函数执行完成返回调用时使用，理由也是要建立一个临时对象中，再返回调用者。为什么不返回局部对象呢？因为局部对象在离开建立它的函数时，就已经消亡了，不可能在返回调用函数后继续生存，所以在处理这种情况时，编译系统会在调用函数表达式中创建一个无名临时对象，该临时对象的生存周期调用拷贝构造函数把该对象的值拷入临时对象，如果返回的是变量，处理过程类似，只是不调用构造函数。主要看是不是新建立一个变量，创建空间
