# 2023

### 引用&

- 引用不是变量
- 引用仅仅是变量的别名
- 引用没有自己独立的空间
- 引用要与它所引用的变量共享空间
- 对引用所要作的改变实际上对于它所引用的改变

- 引用的两个作用: 应用作为参数传递, 引用作为返回值
  - c语言中具有两种传参方式: 值传递-形参值的改变不能对实参产生影响，指针传递通过形参的改变使相应的实参改变，但程序容易产生错误且难以阅读
  - c++多了引用作为参数对传参的任何操作都能改变相应的实参的数据，使函数调用显得简单

### name managling 与 extern c

- c++重载中主要是对函数的名字进行了名字改编，c语言是不可以对名字进行名字改编的
- 如果c++中的函数不想改编，就添加extern c就可以

### inline与define

- 内联函数:当程序执行函数调用时，系统要建立栈空间，保护现场，传递参数以及控制程序的转移等等，这些工作需要系统时间和空间的开销, 有些情况下，函数本身功能简单，
  代码很短，但使用频率却很高，程序频繁调用该函数所花费的时间却很多，从而使得程序执行效率降低。
- 为了提高效率，一个解决办法就是不使用函数，直接将函数的代码嵌入到程序中，这种方法一是相同代码重复书写，二是程序可读性往往没有使用函数的好。
- 为了协调好效率和可读性之间的矛盾，c++提供了另一种方法，及定义内联函数，方法是再定义函数时用修饰次inline
- 内敛函数与带参数宏定义的区别: 内敛函数调用时，要求参数和形参的类型一致，另外内敛函数会对实参表达式进行求值，然后传递给形参，而宏调用时只用实参简单地替换形参。
- 内联函数是在编译的时候，在编译的地方将代码展开的，而宏则是在预处理进行替换的
- 而C++中建议采用inline函数来替换带参数的宏。

### 类型转换

- const\cast
  - 用来移除对象的常量性(const away the constness)
  - const\_cast一般用于指针或者引用
  - 使用const\_cast去除const限定的目的不是为了修改它的内容
  - 使用const\_cast去除const限定，通常是为了函数能够接受这个实际参数
- static\_cast
  - 编译器隐式执行的任何类型转换都是可以static\_cast完成。
  - 当一个较大的算数类型赋值给较小的类型时，可以用shared\_cast进行强制转换。
  - 可以将void* 指针转换为某一类型的指针
  - 可以将基类指针指向派生类指针
  - 无法将const转化为nonconst;这个只有const\_cast才可以办得到
- reinterpret\_cast
  - reinterpret\_cast通常为操作数的位模式提供较低的重新解释，也就是说将数据以二进制存在形式的重新解释。
- dynamic\_cast基类与派生类向下转化

### c++ 类的特性

- 抽象
- 封装
- 继承
- 多态
- 类的设计需要满足开闭原则，软件中的对象(类,模块,函数)应该对于扩展是开放的，对于类的修改是关闭

### 类的构造和析构

- const成员的初始化只能在构造函数初始化列表中进行
- 引用成员的初始化只能在构造函数初始化列表中进行
- 类成员的初始化顺序与初始化列表无关，而与类的私有变量定义顺序有关
- 对于所有的对象都是常量，需要定义为枚举，而不是const
- 当函数的形参是类的对象，调用函数时，进行形参与实参的结合使用，这时要在内存中新建立一个局部对象，并把实参拷贝到新的对象中，理所当然也在调用拷贝构造。
- 当函数的返回值是类的对象，函数执行完成返回调用时使用，理由也是要建立一个临时对象中，再返回调用者。为什么不返回局部对象呢？因为局部对象在离开建立它的函数时，就已经消亡了，不可能在返回调用函数后继续生存，所以在处理这种情况时，编译系统会在调用函数表达式中创建一个无名临时对象，该临时对象的生存周期调用拷贝构造函数把该对象的值拷入临时对象，如果返回的是变量，处理过程类似，只是不调用构造函数。主要看是不是新建立一个变量，创建空间

### 软件UML

- 软件的静态建模和动态建模

### 类之间的关系

- 关联关系，一个类与另一个类之间的固定关系,双方是平级的，比如A的成员函数中有B& b(B的引用)。
- 聚合关系，整体与局部之间的关系，两个类不是平级的是整体(A类)与局部（B类)关系,B的生命周期与A无关
- 组合关系, 公司与部门之间的关系，公司是整体，公司解散后，部门随之解散。公司是A，部门是B,如果A销毁，B也销毁
- 依赖关系，从语义上讲A use B,偶然的，临时的B作为A的成员函数参数,B作为A的成员函数的局部变量；A的成员函数调用B的静态方法。A的函数传参使用了B,或者返回值为B
- 继承，关联，聚合，组合，依赖

### 值语义与对象语义

- 值语义-基于对象编程，值语义是指对象得拷贝与原对象无关，拷贝之后就与原对象脱离关系，彼此独立互不影响，c++中得内置类型都是值语义。string vector map 也是值语义
- 对象语义-面向对象编程:是面向对象下的对象，对象拷贝是禁止的(noncopyable), 一个对象被系统标准的复制方式复制后
- 值语义对象声明周期容易控制
- 对象语义对象生命不容易控制(通过智能指针来解决),智能指针实际上是将对象语义转化为值语义
- 值语义与对象语义是分析模型决定的，语言的语法技巧用来匹配模型。
- auto\_ptr 所有权独占，不能共享，但是可以转义
- shared\_ptr 所有权共享，内部维护了一个引用计数
- weak\_ptr 弱指针，他与shared\_ptr配合使用，解决循环引用问题

### 前向声明

- 头文件比较小,CPP文件包含这个头文件就会增大

### static

- c中有两种用法:
  - 用于函数内部修饰变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的"状态"。使用静态变量的函数一般是不可重入的，也不一定是线程安全的。strock(3);
  - 在文件级别(函数体之外)，修饰变量或函数，表示该变量或函数只在本文件可见，其他文件看不到该变量或者函数。专业的说法叫"具有intenal
    linkage"(简而言之:不暴漏给别的translation unit).
  - c语言的两种用法比较明确，一般不容易混淆。
- c++新增两种用法:
  - 由于C++引入了类，在保持C语言兼容的同时，static 关键字又有了两种新的用法
  - 修饰类的数据成员, 即所谓"静态成员"。这种数据成员的生存期大于class的对象(实例instance).静态数据成员是每个class有一份，普通数据成员是每个instance有一份。
  - 用于修饰class的成员函数，即所谓“静态成员函数”,这种成员函数只是能访问静态成员和其他静态成员函数，不能访问非静态成员和非静态成员函数。 静态成员函数没有this指针。

### 友元函数,友元类

- 友元破坏了类的封装,作用在于提升程序的运行效率
- 友元函数: - 友元函数在类作用域外定义，但是它在类中就行说明 - 为了与该类的成员函数加以区别，定义的方式是在类中用关键字friend说明该函数: friend 类型 友元函数名(参数表);

- 友元类: 如果某类B的成员函数会频繁的存取另一个类A的数据成员，而A的数据成员的Private/Protectd限制造成B存取的麻烦，B只能通过A的public的成员函数进行间接存取 -
  把B做成A类的友元类，即A类向B类开发其Private/Protectd内容，让B直接存取 - 友元类: 一个类可以作为另一个类的友元 - 友元类的所有成员函数都是另一个类的友元函数 -
  友元类的声明: friend class name; - 友元关系是单向的(B是A的友元类，在A中friend class B;)并不代表A是B的友元类，B的一些私有-保护成员，A不能访问 -
  友元关系不能被传递(A是B的友元类，B又是C的友元类，并不代表A是C的友元类) - 友元关系不能被继承(A是B的友元类，C继承自A,并不代表C是B的友元类)

### 重载

- 分为两类:成员函数重载和非成员函数的重载
- 成员函数重载
  - 成员函数原型的格式:
    \
    函数类型 operator 运算符(参数表);
  - 成员函数的定义格式:
    \
    函数类型 类名::operator 运算符(参数表) { 函数体; }
- 非成员函数的重载:
  - 友元函数原型的格式: friend函数类型operator运算符(参数表);
  - 友元函数定义的格式: friend 函数类型 类名::operator 运算符(参数表){函数体;}

### 继承

- 派生类对象指针可以转换为基类指针，将派生类对象看成是基类对象。
- 基类指针无法转换成为派生类指针，无法将基类对象看成是派生类对象
- 派生类到基类的转换:
  - 当派生类以public方式继承,编译器可以自动执行的转换(向上转型upcasting安全转换)
    - 派生类对象指针自动转换为基类对象指针
    - 派生类对象引用转换为基类对象引用
    - 派生类对象自动转换为基类对象(特有的成员消息)
  - 当派生类以private/protected方式继承基类时
    - 派生类对象指针(引用)转化为基类对象指针(引用)需要强制类型转化，但是不能static\_cast,要reubteroret\_cast
    - 不能把派生类对象强制转换为基类对象
- 基类到派生类的转换:
  - 基类对象指针(引用)可以用强制类型转换为派生类对象指针(引用)，而基类对象无法执行这类转换。
  - 向下转型不安全，没有自动转换的机制
- 虚继承与虚基类
  - 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性---采用虚基类来解决。
  - 虚基类的引入
    - 有共同基类的场合
  - 声明
    - 用virtual关键字修饰说明基类: class B1 : public BB
  - 作用
    - 主要用来解决多继承时可能发生的对同一个基类继承多次而产生的二义性问题。
    - 为最远的派生类提供唯一的基类成员，而不重复产生对此拷贝
- 虚基类及其派生类构造函数
  - 虚基类的成员是由最远派生类的构造函数通过调用虚基类构造函数进行初始化的。
  - 在整个继承结构中，直接或者间接继承虚基类的所有派生类，都必须在构造函数的成员初始化列表中给出对虚基类的构造函数的调用，如果未给出，则表示调用该虚基类的默认构造函数。
  - 在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，该派生类的其他基类对虚基类构造函数的调用被忽略。

### 作用域

- 块作用域，文件作用域，函数原型作用域:函数声明，函数作用域:goto语句，类作用域

### 前向声明

- c++中类必须先定义，才能够实例化。
- 两个类需要相互引用形成一个环形引用时，无法先定义使用，这时候就需要用到前向声明
- 前向声明的类不能实例化，只能是指针或者引用

### 嵌套类

- 在类的定义内在定义的类

```cpp
class A
{
public:
    class B
    {
        public:
            void function()
            {
                std::cout << "inner function" << std::endl;
            }
    };
};
```

### 局部类

### unix domain

- socket绑定的路径必须是绝对路径

### socket中close状态的原因

- 程序建立连接后netstat -nap | grep 20300就会查看到所有的连接关系

```
netstat -nap | grep 20300
tcp        0      0 0.0.0.0:20300           0.0.0.0:*               LISTEN      28193/progam1
tcp        0      0 127.0.0.1:47427         127.0.0.1:20300         CLOSE_WAIT  15099/progam2
tcp        0      0 172.20.65.70:20300      172.20.28.45:12158      ESTABLISHED 28193/progam1
tcp        0      0 172.20.65.70:20300      172.20.28.45:11813      TIME_WAIT   -
tcp        0      0 172.20.65.70:20300      172.20.28.47:51660      TIME_WAIT   -
tcp        0      0 172.20.65.70:20300      172.20.28.47:63161      ESTABLISHED 28193/progam1
```

    - 主动关闭的一方发出FIN包,被动关闭的一方响应ACK包，此时，被动关闭的一方就进入了CLOSE\_WAIT状态。如果一切正常，稍后被动关闭的一方就会发送出FIN包，然后迁移到LAST\_WAIT状态。
    -

<++>
